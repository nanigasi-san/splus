# C(K)=nの状態の列挙
## 目次
1. 概要
2. S+
3. グラフの拡張
4. 操作対象の列挙

## 1. 概要
自明な結び目に対してRI+/RI-を任意回、S+をn回行うことで現れる結び目をstep nとし、任意のnが与えられたときにstep nの結び目を全て列挙することを考える。

これは、結び目に対するS+を結び目オイラーグラフ(KEG)に対する操作に変換することで実現できる。

---

## 2. グラフの拡張
あるKEGについて、S+を行える部分を漏らしなく列挙するためには、以下の操作を可能な限りする必要がある

+ RI+
+ 頂点の分割

### RI+
(u, v, Tu, Tv)という辺があるとき、その辺を削除し、Odd頂点Oを追加し、辺(u, O, Tu, A), (O, O, B, A), (O, v, B, Tv)という辺を追加する。

### 頂点の分割
実頂点は、それぞれ以下のように分割できる
+ Odd: Odd + Even / Even + Odd
+ Even: Odd + Odd / Even + Even

#### 手法
各頂点(Odd or Even)に対して2通りの分割が考えられる。それぞれを厳密に書くと以下の通りになる。
##### Odd->Odd+Even
##### Odd->Even+Odd
##### Even->Odd+Odd
##### Even->Even+Even
#### 計算量
統合済みの実頂点がn個あるとき、各頂点についてあり得る状態数が2つなので、グラフ1つについて$2^n$個の派生が考えられる。ここが最悪なので後々効率化したい(特にO->O+E/E+Oを片方にまとめられないか。これは実際に計算して同値判定すればわかる。E->O+O/E+Eは難しそうだけど頑張ること)。
(IDEA: つなぎ直した後にOdd-Even入れ替えたら一回分のS+操作で二個生成できるのでは？)


### 空頂点の挿入が不要な理由
step0に対してS+をするために導入した空頂点の概念は、step1以降の操作には必要ない。何故なら、空頂点の意義とは「結び目として1つの辺にS+をしたいが、グラフとしてはS+を行うのに辺が2つ必要なので辺を2つに分割するための仮想的な頂点」であり、これは「空頂点の挿入を行い、その前後の辺を対象に空頂点の削除を行った後にRI-を行う」と「RI+を行い、その前後の辺を対象にS+を行った後にRI-を行う」で同じ結果になるためである。

---

## 3. 操作対象の列挙
これは4の手順1,2の詳細である。

### 前提
S+はグラフへの操作だが、本質的にはオイラー閉路のうち二辺に対する操作である。あるグラフGが与えられたとき、Gに対応するオイラー閉路ec(辺のリスト)が一つに定まるが、その閉路の中でS+の対象となりうる辺のペアは複数現れる。よってそのペア(操作対象)を列挙することが必要である。

### 列挙の手法
1. グラフGのオイラー閉路ECを求める。ecの長さをnとする。
2. ecを2個つなげる。
3. i=[0, n-1]をループし、e_s=ec[i]とする。j=[1, n-1]とし、e_g=ec[i+j]とする。

このようにして`n*(n-1)`組のペアが列挙できるので、それぞれにS+をする。

### 具体例
(TODO: 中身を用意)

(拡張済みのstep1の画像)

(上の画像のデータ、頂点と辺のリスト)

(上の画像のEC)

上の場合S+の対象になるペアは
```
いい感じのfor文
```
で列挙できます。

### 計算量
+ 1: オイラー閉路の取得→DFSなので$O(E+V)$=$O(E)$
+ 2: 始辺と終辺を選ぶ→E辺それぞれについて(E-1)ペア作れるので$O(E^2)$

トータル$O(E^2)$

---

## 4. S+
### 手順
S+は以下の操作に置き換えられる。
1. オイラー閉路を辺のリストで持つ
2. オイラー閉路から始辺e_s(a, b, Ta, Tb)と、終辺e_g(c, d, Tc, Td)を選ぶ(この時e_s<e_gとなるようにする)
3. Odd頂点Oを追加する。
4. a, bからOに、Oからc, dに繋がるように辺を追加する。この時aとd, bとcがそれぞれOの同じ側(A/B)に繋がるようにする。即ち、(a, O, Ta, A), (b, O, Tb, B), (O, c, B, Tc), (O, d, A, Td)の4辺を追加する。
5. オイラー閉路でe_sとe_gの間にある辺全てを逆向きにした辺を追加する。即ち、(u, v, Tu, Tv)を(v, u, Tv, Tu)にする。
6. e_sからe_gまでの辺を削除する

### 反転する理由
1. (a, b)の辺が(a, O), (b, O)に変わるため、bの次数を考えると、(入:出)=(2-1:2+1)=(1:3)になっている。KEGの実頂点は、次数が4であり、かつ入力次数と出力次数が同じである必要がある。つまり(入：出)=(2:2)である必要がある。頂点bの場合、出力次数を一つ減らし、入力次数を一つ増やす必要がある。

2. (c, d)の辺が(O, c), (O, d)に変わるため、cの次数を考えると、(入:出)=(2+1:2-1)=(3:1)になっている。KEGの実頂点は、次数が4であり、かつ入力次数と出力次数が同じである必要がある。つまり(入：出)=(2:2)である必要がある。頂点cの場合、入力次数を一つ減らし、出力次数を一つ増やす必要がある。

3. 指定範囲のオイラー閉路を頂点の並びで表したとき、[a, b, ..., c, d]となる。[b, ..., c]の`...`の部分(これは路である)をXとおく。Xを反転したものをX'とする。この時、XをX'に変換したとき、Xに含まれるすべての頂点で次数の(入:出)の比は保存される。何故なら、Xに含まれる頂点p_xについていて、辺(u, p_x)と辺(p_x, v)が,存在し、これが反転して(v, p_x), (p_x, u)になるためである。

4. 1, 2, 3を踏まえて、[b, X, c]の部分を反転して[c, X', b]にすることを考える。この時、頂点bについてbからの出力次数が一つ減り、入力次数が一つ増えている(1)。頂点cについて、cからの入力次数が一つ減り、出力次数が一つ増えている(2)。また、XからX'についての変換において次数の関係は保存されている(3)。即ち、Odd頂点への辺の繋ぎ変えと、辺の反転をすることで登場するすべての頂点における次数の比が保たれる。

### 操作例
+ step0 → step1 (*1)
+ step1 → step2 (*3)

の4ケースについて以下に記す。辺の番号付けは0-indexedとする。

#### step0 → step1
![step0のグラフの絵](./images/step0.jpg)

[(0, 1, N, N), (1, 0, N, N)]

区間(0, 1)を対象にS+を行う。

1. Odd頂点2を追加。
2. a=0, Ta=N, b=1, Tb=N, c=1, Tc=N, d=0, Td=Nとして、頂点2と繋がる辺を追加。(0, 2, N, A),(1, 2, N, B),(2, 1, B, N),(2, 0, A, N)の4辺。
3. (0, 1, N, N), (1, 0, N, N)を消去。

最終的に残る辺は[(0, 2, N, A),(1, 2, N, B),(2, 1, B, N),(2, 0, A, N)]の4辺。

![step1のグラフの絵](./images/step1.jpg)

(TODO: 空頂点を消したバージョンに書き換える)

#### step1 → step2-1
![step1のグラフの絵](./images/step1.jpg)

[(0, 2, N, A), (2, 1, B, N), (1, 2, N, B), (2, 0, A, N)]

区間(1, 2)を対象にS+を行う。

1. Odd頂点3を追加。
2. a=2, Ta=B, b=1, Tb=N, c=1, Tc=N, d=2, Td=Bとして、頂点3と繋がる4辺を追加。(2, 3, B, A), (1, 3, N, B), (3, 1, B, N), (3, 2, A, B)の4辺。
3. (2, 1, B, N), (1, 2, N, B)を消去。

[(0, 2, N, A), (2, 0, A, N), (2, 3, B, A), (1, 3, N, B), (3, 1, B, N), (3, 2, A, B)]

![step2-1](./images/step2_1.jpg)


#### step1 → step2-2
step1にRI+を行い、Odd頂点3が追加され以下の状態になる。
![step1_RIplus](./images/step1_riplus.jpg)

[(1, 2, N, B), (2, 0, A, N), (0, 3, N, A), (3, 3, B, A), (3, 2, B, A), (2, 1, B, N)]
区間(0, 3)を対象にs+を行う。
1. Odd頂点4を追加
2. a=1, Ta=N, b=2, Tb=B, c=3, Tc=B, d=3, Td=Aとして、頂点3と繋がる4辺を追加。(1, 4, N, A), (2, 4, B, B), (4, 3, B, B), (4, 3, A, A)の4辺。
3. (1, 2, N, B), (3, 3, B, A)を消去。
4. (2, 0, A, N), (0, 3, N, A)を反転して(0, 2, N, A), (3, 0, A, N)にする。

[(3, 2, B, A), (2, 1, B, N), (1, 4, N, A), (2, 4, B, B), (4, 3, B, B), (4, 3, A, A), (0, 2, N, A), (3, 0, A, N)]

頂点3, 4はOdd+Odd->Evenに統合でき、Even頂点5の追加とと空頂点の削除をすると以下の通りになる。

[(2, 5, B, B), (5, 2, B, A), (2, 5, B, A), (5, 2, A, A)]

![step2-2](./images/step2_2.jpg)

#### step1 → step2-3
step1に頂点分割を行い、Odd頂点3, Even頂点4が追加され以下の状態になる
![step1_split](./images/step1_split.jpg)

[(3, 4, A, A), (4, 3, A, A), (3, 4, B, B), (4, 3, B, B)]
区間(0, 1)に対してS+を行う。

1. Odd頂点5を追加
2. a=3, Ta=A, b=4, Tb=A, c=4, Tc=A, d=3, Td=Aとして、頂点5と繋がる4辺を追加。 (3, 5, A, A), (4, 5, A, B), (5, 4, B, A), (5, 3, A, A)
3. (3, 4, A, A), (4, 3, A, A)を削除。

[(3, 4, B, B), (4, 3, B, B), (3, 5, A, A), (4, 5, A, B), (5, 4, B, A), (5, 3, A, A)]

![step2_3](./images/step2_3.jpg)

### 計算量
操作の核心部分である3~6のそれぞれについて考えると
+ 3: Odd頂点の追加→一個なので$O(1)$
+ 4: Odd頂点への4辺の追加→定数なので$O(1)$
+ 5: 間の辺を逆にする→最大E-2辺に行われるので$O(E)$
+ 6: 逆転前の辺を削除する→最大E-2辺に行われるので$O(E)$

辺の数をEとして$O(E)$

---

## 5.まとめ
### 計算量
+ 1~2で$O(E^2)$
+ 3~6で$O(E)$

1~2で生成したペアに対しS+を行うので、あるKEGについてS+をしたものを列挙するには$O(E^3)$かかる